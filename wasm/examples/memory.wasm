#meta
name: "Memory"
author: "Kai Tamkun"
orcid: "0000-0001-7405-6654"
version: "1"
library

#includes
"examples/string.why"

#data
globalbase: 0 // pointer to first block in the list.
msg_cantallocate: "\u001b[38;5;9mCouldn't find a free block.\u001b[0m"
ptrtoblock: 0
msg_addr: "Address of current block: "
msg_cond: "Block is unfree or too small? "
msg_done: "Mission accomplished? "
msg_bsize: "Size of first block: "
msg_free: "First block free? "
msg_rsize: "Requested size: "
msg_success: "\u001b[32mFound a free block at \u001b[0m"
msg_markfree: "\u001b[38;5;226mMarking first block as free and retrying allocation.\u001b[0m\n\n"
ansi_reset: "\u001b[0m"
ansi_bold: "\u001b[1m"

#code

1 -> $s6
'\n' -> $s7
'.' -> $s8

// https://danluu.com/malloc-tutorial/

:: mem_init

&.end -> $s0
$s0 -> [ptrtoblock]
&ptrtoblock -> $a0
20 -> $a1

@attempt
[$g] -> $s0
!strprint(&msg_bsize); <prd $s0>; <prc $s7>
$g + 16 -> $s0
[$s0] -> $s0
!strprint(&msg_free); <prd $t0>; <prc $s7>
!strprint(&msg_rsize); <prd $a1>; <prc $s7>; <prc $s7>

:: find_free_block

@checkresults
<prc $s7>
: success if $r0

!strprint(&msg_cantallocate)
: done

@success
!strprint(&msg_success)
!strprint(&ansi_bold)
<prd $r0>
!strprint(&ansi_reset)
<prc $s8>
<prc $s7>

@done
<prc $s7>

: tryagain if $s6
<halt>

@tryagain
0 -> $s6
<prc $s7>; <prc $s7>
!strprint(&msg_markfree)
$g + 16 -> $t0
1 -> $t1
$t1 -> [$t0]
: attempt

<>;<>;<>
sub mem_init() {
	&.end -> $g
	$g -> [globalbase]

	// Initialize first block.
	$g -> $k0
	40 -> $k1               // size = 5w
	$k1 -> [$k0]; $k0 += 8
	$g + 80 -> $k1          // next = end+10w
	$k1 -> [$k0]; $k0 += 8
	0 -> $k1                // free
	$k1 -> [$k0]; $k0 += 8
	$0 -> [$k0]             // magic = 0
}
<>;<>;<>

/*
	struct block_meta { // 4 words total
		word size;
		ptr *next;
		word free;
		word magic;
	};
*/



/*
struct block_meta *find_free_block(struct block_meta **last, size_t size) {
	struct block_meta *current = global_base;
	while (current && !(current->free && current->size >= size)) {
		*last = current;
		current = current->next;
	}
	return current;
}
*/

<>;<>;<>
sub find_free_block() {
	// $a0, $a1  ->  $r0
	
	// $a0: pointer to pointer to the last block.
	// $a1: size of the block to allocate.
	// $t0: block *current
	// $t1: &(current->next)
	// $t2: !(current->free && current->size >= size), final result of conditional

	// $r0: pointer to block.

	*globalbase -> $t0
	: ffb_loop

	@ffb_condition
		$t0 + 16 -> $t1
		@CheckFree
		[$t1] -> $t2 // $t2 = current->free

		@CompareSize
		[$t0] -> $t3      // $t3 = current->size
		$t3 >= $a1 -> $t3 // $t3 = current->size >= size

		@FreeAndSize
		$t2 && $t3 -> $t2 // $t2 = current->free && current->size >= size
		!$t2.             // $t2 = !(current->free && current->size >= size)

		!strprint(&msg_addr); !bold($t0)
		!strprint(&msg_cond); !bold($t2)

		@FullConditional
		$t0 && $t2 -> $t2 // $t2 = current && !(current->free && current->size >= size)
		!$t2.
		!strprint(&msg_done); !bold($t2)
		: ffb_done if $t2
		ret

	@ffb_loop
		: ffb_condition
		@SetPointer
		$t0 -> [$a0] // $ *last = current
		@MoveNext
		$t0 + 8 -> $t1
		[$t1] -> $t0 // $t0 = current->next
		@Repeat
		: ffb_loop
		
	@ffb_done
		$t0 -> $r0
}
<>;<>;<>

sub bold() {
	!strprint(&ansi_bold)
	<prd $a0>
	!strprint(&ansi_reset)
	<prc $s7>
}

sub malloc() {
	// $a0: number of bytes to allocate
	// $r0: pointer to allocated memory; 0 if unsuccessful.

}
